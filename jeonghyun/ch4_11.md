# 4장 변수

## 식별자

    식별을 위해 지은 이름

- 메모리 주소 기억(식별자가 없으면 사람이 0x00... 같은 주소를 기억 해야함)
- var, let, const로 선언
- 선언 단계: 실행 컨텍스트에 등록
- 초기화 단계: 메모리 확보, undefined 할당
- 런타임: 코드 실행(인터프리터식) 단계, 이전에 선언 단계와 초기화 단계가 진행됐기 때문에 호이스팅이 가능

#

#

# 5장 표현식과 문

## 값

    표현식이 평가되어 생성된 결과

- 변수에 할당되는 것은 값

## 리터럴

    사람이 이해하는 문자, 기호로 값을 생성하는 표기법

- 리터럴 3(사람이 알고 있는 그 3) 작성 => 작성된 리터럴에 해당하는 값 생성(리터럴 !== 값)

## 표현식

    값으로 평가되는 식

- 값을 생성하거나 참조
- 변수 할당 가능 여부로 표현식인지 아닌지 구분 가능
- ex) 템플릿 리터럴 => 문자열로 반환되고, 할당이 됨 => 표현식

#

#

# 6장 데이터 타입

    원시: number, string, boolean, undefined, null, symbol
    객체: Object, Function, Array, ...

#

#

# 9장 타입 변환과 단축 평가

    명시적: NUMBER_VALUE.toString()
    암시적: NUMBER_VALUE + ''

- 옵셔널 체이닝 연산자

  const result = VALUE?.value

  VALUE === null or undefined ? undefined : VALUE.value

- null 병합 연산자

  const result = VALUE ?? "value"

  VALUE === null or undefined ? "value" : VALUE

#

#

# 10장 객체 리터럴

## 객체

    다양한 타입의 값을 하나의 단위로 구성한 복합적 자료구조

- 값 변경 가능(원시 값은 변경 불가)
- 프로퍼티(속성): 키: 값으로 구성

  네이밍\_규칙: 값 or "네이밍 규칙 아님": 값

- 메소드: 참조, 조작과 같은 동작(일반 함수와 구분하기 위해 메소드라 함)
- 객체.없는\_속성 = VALUE => 없는\_속성 추가 및 VALUE 할당
- delete 객체.있는\_속성 => 있는\_속성 삭제

#

#

# 11장 원시 값과 객체의 비교

| 원시 값      | 객체               |
| ------------ | ------------------ |
| 변경 불가    | 변경 가능          |
| 실제 값 저장 | 참조 값(주소) 저장 |
| 값 전달      | 참조 전달          |

## 원시 값

- 메모리에 할당 된 값이 원시 값일 때 그 메모리에는 값 변경 불가(불변성)

  변수에 값이 변할 때 새 메모리에 바뀐 값을 할당하고 변수의 주소가 바뀜(값이 변경 가능하다면 주소를 바꿀 필요가 없음)

  문자열: STRING_VALUE[0] = 's' 불가(원시 값이기 때문)  
   => STRING_VALUE = 's'는 재할당이라 위 매커니즘으로 진행

- 변수로 다른 변수에 할당하면 값은 같아도 각각 메모리에 저장되므로 별개의 값임

  값의 의한 전달도 메모리 주소를 전달함(같은 값인 새로운 주소를 전달)

  각 변수의 값이 변해도 서로 영향 없음

## 객체

- 메모리에 할당된 값에서 변경이 가능함
- 변수로 다른 변수에 할당하면 주소 값을 전달(참조 전달)함
- 여러 개의 식별자가 공유할 수 있음(수정도 공유됨)
