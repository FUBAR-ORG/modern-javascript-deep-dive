# 12장 함수

    문으로 구성, 하나의 실행 단위로 정의한 것

- 재사용성
- 일반 객체는 호출할 수 없지만 함수는 호출 가능
- 함수 선언문: function func() {}

  - 이름을 생략할 수 없음
  - 표현식이 아닌 문
  - 식별자로 호출
  - 호이스팅 가능

- 함수 표현식: const func = function() {}
  - 일급 객체(할당 가능, 프로퍼티 값 가능, 배열 요소 가능)
  - 표현식
  - 런타임에 평가되므로 실행 때 함수가 됨 => 변수만 호이스팅
- 생성자 함수: const func = new Function()
  - 바람직하지 않음 ?
  - 클로저가 생성되지 않고 다른 방식과 다르게 동작
- 화살표 함수: const func = () => {} //es6
  - 변수만 호이스팅
  - 생성자 함수로 사용할 수 없음
  - 기존 함수와 this 바인딩 방식이 다름 ?
  - prototype 프로퍼티가 없음
  - arguments 객체를 생성하지 않음
- 함수는 한 가지 일만 해야하며 가급적 작게 만들어야 한다
- 함수 호출은 표현식
- 즉시 실행 함수: 함수 리터럴을 평가해서 객체를 생성(그래서 보통 그룹 연산자'()' 사용)
  - (function(){}())
  - (function(){})()
  - !function(){}()
  - +function(){}()
  - () //피연산자가 없기 때문에 에러
  - function foo(){}() //피연산자가 없기 때문에 에러
- 중첩 함수 === 내부 함수: 외부 함수 내 정의, 호출(외부 함수를 돕는 헬퍼 함수)
- 콜백 함수: 매개 변수로 넘어가는 함수
- 순수 함수: 의존하지도 외부를 변경하지도 않는 함수

#

#

# 13장 스코프

    매개 변수를 참조할 수 있는 유효 범위

- 모든 식별자는 선언된 위치에서 스코프를 가짐
- 식별자 결정: 같은 변수 이름이 있을 때 어느 것을 쓸지 결정

  => 스코프는 식별자를 검색할 때 사용하는 규칙

- 스코프 체인: 함수 구조에 따라 계층형적으로 연결된 여러 스코프
- 함수 레벨 스코프: 함수에 의해서만 지역 스코프 생성

#

#

# 14장 전역 변수의 문제점

- 암묵적 결합: 모든 코드가 변경할 수 있음
- 긴 생명 주기: 코드 로드 부터 실행문이 없을 때까지
- 스코프 끝: 검색 속도가 느림
- 네임 스페이스 오염: 전역에 있다보니 같은 이름의 변수 충돌이 쉬움

## 변수의 생명 주기

    선언에 의해 생성되고 할당을 통해 값을 갖고 생성된 위치에서 소멸함, 주기가 없다면 프로그램 끝날 때까지 메모리 점유

#

#

# 18장 함수와 일급 객체

1. 무명의 리터럴로 생성할 수 있다. 즉 런타임에 생성이 가능하다.
2. 변수나 자료구조에 저장할 수 있다.
3. 함수의 매개변수에 전달할 수 있다.
4. 험수의 반환값으로 사용할 수 있다.

=> 값처럼 쓸 수 있다.
