# 12장 함수

## 함수 선언문은 표현식인가?

**함수 선언문은 표현식이 아닌 문이다.** 만약 함수가 표현식인 문이라면 표현식이 평가되어 생성된 함수가 출력되어야 하지만 완료 값 `undefiend`가 출력된다.

**그런데 왜 함수 선언문은 변수에 할당이 되는 것처럼 보일까?**

`{ }`는 블록 문일수도 있고 객체 리터럴일수도 있다. 마찬가지로 함수 선언문은 함수 리터럴과 형태가 동일하다.(리터럴은 함수 이름이 생략 가능)

js 엔진은 함수 리터럴을 단독으로 사용하면 함수 선언문으로 해석하고, 변수 할당이나 피연산자 같이 함수 리터럴이 값으로 평가되어야 하는 부분에서는 함수 리터럴 표현식으로 해석한다.

따라서 **함수 선언문이 변수에 할당되는 것이 아닌 값으로 평가되는 함수 리터럴이 변수에 할당되는 것이다.**

함수 선언문과 함수 리터럴은 둘 다 함수 객체를 생성하지만 함수 리터럴 표현식으로 생성된 함수는 함수를 가르키는 식별자가 없기 때문에 호출할 수 없다.

기명 함수 리터럴은 함수 바디내에서만 참조할 수 있는 식별자를 가지고 있다. 반면 함수 선언문으로 생성된 함수는 js가 생성된 함수를 호출하기 위해서 함수 이름과 동일한 이름의 식별자를 암묵적으로 생성하고 메모리에 생성된 함수 객체를 가르키는 참조를 만든다.

<br>

## 함수 호이스팅

**함수 선언문으로 정의한 함수와 함수 표현식으로 정의한 함수는 함수의 생성 시점이 다르다.**

이를 이해하기 위해서는 함수 호이스팅과 변수 호이스팅의 차이를 이해해야한다.

`var` 키워드로 선언된 변수는 `undefined`로 초기화되므로 변수 선언 이전에 호출하면 `undefined`로 평가된다.

반면 함수 선언문을 통해 암묵적으로 생성된 식별자는 함수 객체로 초기화된다. 따라서 함수 선언문 이전에 호출하면 함수 호이스팅에 의해 호출이 가능하다.

변수 선언은 런타임 이전에 실행되며 `undefined`로 초기화되지만 할당문의 값은 런타임에 평가된다. 함수 표현식에 할당되는 함수 리터럴도 마찬가지로 런타임에 평가되어 함수 객체가 된다. 즉, **함수 표현식으로 함수를 정의하면 함수 호이스팅이 아닌 변수 호이스팅이 발생한다.**

<br>

## 매개변수에 값을 전달하는 방식

원시 타입 인수는 값 자체가 복사되어 매개변수에 전달된다. 반면 객체 타입 인수는 참조 값이 복사되어 전달되기 때문에 함수 내부에서 참조 값을 통해 객체를 변경할 수 있다.

이를 방지하기 위한 방법으로 `JSON.parse(JSON.stringify(object))`와 같이 원본 객체의 깊은 복사를 통해 객체를 immutable한 객체로 만들어 사용하는 방법이 있다.

<br>

## 콜백 함수, 순수/비순수 함수

콜백 함수: 함수의 매개변수를 통해 다른 함수로 전달되는 함수

고차 함수 (HOF): 매개변수를 통해 함수의 외부에서 콜백 함수를 전달받은 함수

고차 함수에 콜백 함수를 전달할 때는 콜백 함수를 호출하는 것이 아닌 함수 자체를 전달해야 한다.

<br>

순수 함수는 외부 상태에 의존하지않고 외부 상태를 변경하지도 않는 side effect가 없는 함수이다.

```js
// 순수 함수
function pure(n) {
  return ++n;
}

// 비순수 함수
function impure() {
  // 외부 상태에 의존 및 변경
  return ++cnt;
}

var cnt = 0;

pure(cnt);
console.log(cnt); // 0
impure();
console.log(cnt); // 1
```
