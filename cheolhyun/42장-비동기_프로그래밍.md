# 비동기 프로그래밍

## 동기 처리와 비동기 처리

- 실행 컨텍스트 스택에 함수 실행 컨텍스트가 푸시되는 것은 함수 실행의 시작을 의미.
- 함수가 호출된 순서대로 순차적으로 실행되는 이유는 순서대로 스택에 푸시되기 때문.
- `JavaScript Engine`은 단 하나의 실행 컨텍스트 스택을 가짐.
  - 2개 이상의 함수를 동시에 실행할 수 없음.
- 실행 중인 실행 컨텍스트를 제외한 모든 실행 컨텍스트는 실행 대기 중인 태스크(`task`) 들임.
- 대기 중인 태스크는 현재 실행 중인 실행 컨텍스트가 스택에서 제거되면 실행.
- `JavaScript Engine`은 싱글 스레드 방식이기 때문에 시간이 걸리는 태스크를 실행하면 블로킹(작업 중단, `blocking`)이 발생

- 동기 처리 방식: 실행 순서가 보장되지만 블로킹 발생
- 비동기 처리 방식: 블로킹이 발생하지 않지만 실행 순서 미보장

- 비동기 함수는 전통적으로 콜백 패턴을 사용.

  - 콜백 패턴은 콜백 헬을 발생시켜 가독성을 나쁘게 함.
  - 에러의 예외 처리가 곤란.
  - 여러 개의 비동기 처리를 한 번에 하는 데도 한계.

- `setTimeout`, `setInterval`, `HTTP` 요청, 이벤트 핸들러는 비동기 처리 방식으로 동작.

> 비동기 처리는 이벤트 루프와 태스크 큐와 깊은 관계.

## 이벤트 루프와 태스크 큐

- 이벤트 루프(`event loop`): `JavaScript`의 동시성(`concurrency`)를 지원하는 것.
  - 브라우저에 내장되어 있는 기능 중 하나.

> 콜 스택(`call stack`)  
> 실행 컨텍스트 스택.  
> 함수를 호출하면 함수 실행 컨텍스트가 순차적으로 콜 스택에 푸시되어 순차적으로 실행.  
> `JavaScript Engine`은 단 하나의 콜 스택을 사용하기 때문에 최상위 실행 컨텍스트가 종료되어 콜 스택에서 제거되기 전까지는 다른 어떤 태스크도 실행되지 않음.
>
> 힙(`heap`)  
> 객체가 저장되는 메모리 공간.  
> 콜 스택 요소인 실행 컨텍스트는 힙에 저장된 객체 참조.
> 메모리에 값을 저장하려면 먼저 값을 저장할 메모리 공간의 크기를 결정해야 하는데,  
> 객체는 원시 값과는 달리 크기가 정해져 있지 않으므로 할당해야 할 메모리 공간의 크기를 런타임에 결정(동적 할당) 해야 함.  
> 따라서 객체가 저장되는 메모리 공간인 힙은 구조화되어 있지 않음.

- 비동기 처리에서 소스 코드의 평가와 실행을 제외한 모든 처리는 `JavaScript`를 구동하는 환경(브라우저, `Node.js`)가 담당.

  - 비동기 방식으로 동작하는 `setTimeout`의 콜백 함수의 평가와 실행은 `JavaScript Engine`이 담당.
  - 호출 스케줄링을 위한 타이머 설정과 콜백 함수의 등록은 브라우저, `Node.js`가 담당.

- 브라우저 환경은 태스크 큐와 이벤트 루프를 제공
  - 태스크 큐(`task queue`/`event queue`/`callback queue`)
    - `setTimeout`과 같은 비동기 함수의 콜백 함수 또는 이벤트 핸들러가 일시적으로 보관되는 영역.
    - 태스크 큐와는 별도로 후속 처리 메서드의 콜백 함수가 일시적으로 보관되는 마이크로태스크 큐도 존재.
  - 이벤트 루프(`event loop`)
    - 콜 스택에서 현재 실행 중인 실행 컨텍스트가 있는지, 그리고 태스크 큐에 대기 중인 함수(콜백 함수, 이벤트 핸들러 등)가 있는지 반복해서 확인.
    - 콜 스택이 비어 있고 태스크 큐에 대기 중인 함수가 있다면 이벤트 루프는 순차적(`FIFO`)으로 태스크 큐에 대기 중인 함수를 콜 스택으로 이동.
    - 콜 스택으로 이동한 함수는 실행. 즉, 태스크 큐에 일시 보관된 함수들은 비동기 처리 방식으로 동작.

```js
function foo() {
  console.log("foo");
}

function bar() {
  console.log("bar");
}

setTimeout(foo, 0);
bar();
```

- 코드 실행 순서

  1. 전역 코드가 평가되어 전역 실행 컨텍스트가 생성되고 콜 스택에 푸시

  2. 전역 코드가 실행되기 시작하며 `setTimeout` 함수가 호출.

     - `setTimeout` 함수의 함수 실행 컨텍스트 생성 후 콜 스택에 푸시.
     - 현재 실행 중인 컨텍스트가 됨.
       > 호스트 객체인 타이머 함수도 함수이므로 함수 실행 컨텍스트를 생성.

  3. `setTimeout` 함수가 실행되면 콜백 함수를 호출 스케줄링하고 종료되어 콜 스택에서 팝.

     - 호출 스케줄링. 즉, 타이머 설정과 타이머 만료가 되면 콜백 함수를 태스크 큐에 푸시하는 것은 브라우저의 역할.

  4. 브라우저와 `JavaScript Engine`이 병행 처리.

     - 브라우저

       - 타이머를 설정하고 타이머의 만료를 기다림.
       - 타이머가 만료되면 콜백 함수 `foo`가 태스크 큐에 푸시
       - 실제로는 `0`이어도 약 `4ms` 후에 콜백 함수 `foo`가 태스크 큐에 푸시되어 대기

       > 따라서 정확히 지연 시간 후에 호출된다는 보장은 없으며, 태스크 큐에 푸시되는 것.

     - `JavaScript Engine`

       - `bar` 함수가 호출되어 `bar` 함수의 함수 실행 컨텍스트가 생성되고 콜 스택에 푸시되어 현재 실행 중인 실행 컨텍스트가 됨.
       - 이후 `bar` 함수가 종료되어 콜 스택에서 팝.
       - 이때 브라우저가 타이머를 설정한 후 `4ms`가 경과했다면 `foo` 함수는 아직 태스크 큐에서 대기 중.

  5. 전역 코드 실행이 종료되고 전역 실행 컨텍스트가 콜 스택에서 팝되어 콜 스택에는 아무런 실행 컨텍스트도 존재하지 않게 됨.

  6. 이벤트 루프에 의해 콜 스택이 비어 있음이 감지되고 태스크 큐에서 대기 중인 콜백 함수 `foo`가 이벤트 루프에 의해 콜 스택에 푸시.

  > 콜백 함수 `foo`의 함수 실행 컨텍스트가 생성되고 콜 스택에 푸시되어 현재 실행 중인 실행 컨텍스트가 됨.

  > 이후 `foo` 함수가 종료되어 콜 스택에서 팝

- 이처럼 비동기 함수인 `setTimeout`의 콜백 함수는 태스크 큐에서 푸시되어 대기하다가 콜 스택이 비게 되면,
- 다시 말해 전역 코드 및 명시적으로 호출된 함수가 모두 종료하면 비로소 콜 스택에 푸시되어 실행.
- `JavaScript`는 싱글 스레드이지만, 브라우저가 싱글 스레드가 아닌 `JavaScript Engine`이 싱글 스레드.
- `JavaScript Engine`은 싱글 스레드, 브라우저는 멀티 스레드.

> 브라우저와 `JavaScript Engine`이 협력하여 비동기 함수인 `setTimeout` 함수를 실행.
