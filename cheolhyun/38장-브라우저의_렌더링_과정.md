# 브라우저의 렌더링 과정

- 웹 애플리케이션의 클라이언트 사이드 `JavaScript`는 브라우저에서 `HTML`, `CSS`와 함께 실행.

- 브라우저의 파싱(해석), 렌더링 과정.

  1. 브라우저는 `HTML`, `CSS`, `JavaScript`, 이미지, 폰트 등의 렌더링에 필요한 리소스를 요청하고 서버로부터 응답 받음.
  2. 브라우저의 렌더링 엔진은 서버로부터 응답된 `HTML`과 `CSS`를 파싱하여 `DOM`과 `CSSOM`을 생성하고, 이들을 결합하여 렌더 트리를 생성.
  3. 브라우저의 `JavaScript Engine`은 서버로부터 응답된 `JavaScript`를 파싱하여 `Abstract Syntax Tree`(`AST`)를 생성하고 바이트코드로 변환하여 실행.
     > 이때 `JavaScript`는 `DOM API`를 통해 `DOM`이나 `CSSOM` 변경 가능.  
     > 변경된 `DOM`과 `CSSOM`은 다시 렌더 트리로 결합.
  4. 렌더 트리를 기반으로 `HTML` 요소의 레이아웃(위치와 크기)를 계산하고 브라우저 화면에 `HTML` 요소를 페인팅.

## 요청과 응답

- 브라우저의 핵심 기능은 필요한 리소스(`HTML`, `CSS`, `JavaScript`, 정적 파일, 서버가 동적으로 생성한 데이터)를 서버에 요청(`request`)하고, 서버로부터 응답(`response`) 받아 브라우저에 시각적으로 렌더링하는 것.
- 브라우저 주소창에 `URL`을 입력하면 `URL`의 호스트 이름이 `DNS`를 통해 `IP` 주소로 변환되고, 이 `IP` 주소를 갖는 서버에 요청을 전송.
- 서버는 루트 요청에 대해 암묵적으로 `index.html`을 응답하도록 기본 설정.
- 다른 정적 파일을 요청하기 위해서는 정적 파일의 경로를 `URI`의 호스트 뒤 패스(`path`)에 기술하여 요청.
- `JavaScript`를 통해 동적으로 서버에 정적/동적 데이터 요청 가능.

- `index.html` 뿐만 아니라 `CSS`, `JavaScript` 등의 리소스도 응답되는 이유.
  > 브라우저의 렌더링 엔진이 `HTML`(`index.html`)을 파싱하는 도중에 `link`, `img`, `script` 등의 외부 리소스를 로드하는 태그를 만나면 `HTML` 파싱을 일시 중단하고 리소스 파일을 서버로 요청하기 때문.

## `HTTP 1.1`과 `HTTP 2.0`

- `HyperText Transfer Protocol`(`HTTP`)는 웹에서 브라우저와 서버가 통신하기 위한 프로토콜(규약).

- `HTTP 1.1`은 기본적으로 커넥션(`connection`)당 하나의 요청과 응답만 처리.

  - 여러 개의 요청을 한 번에 전송할 수 없고 받을 수 없음.
  - `HTML` 문서 내에 포함된 여러 개의 리소스 요청이 개별적으로 전송되고 응답 또한 개별적으로 받음.

  > 리소스 동시 전송이 불가능한 구조이므로 요청할 리소스 개수에 비례하여 응답 시간도 증가하는 단점.

- `HTTP 2.0`은 커넥션당 여러 개의 요청과 응답. 즉, 다중 요청/응답이 가능.

  > `HTTP 1.1`에 비해 페이지 로드 속도가 약 50% 정도 빠르다고 알려짐.

## `HTML` 파싱과 `DOM` 생성

- 브라우저의 요청에 의해 서버가 응답한 `HTML` 문서는 문자열로 이루어진 순수한 텍스트.
- 브라우저 렌더링 엔진은 응답받은 `HTML` 문서를 파싱하여 브라우저가 이해할 수 있는 자료구조인 `Document Object Model`(`DOM`)을 생성.

- 브라우저 렌더링 엔진 `DOM` 생성 과정

  1. 서버에 존재하던 `HTML` 파일이 브라우저의 요청에 의해 응답.
  2. 서버는 브라우저가 요청한 `HTML` 파일을 읽어 들여 메모리에 저장한 다음 메모리에 저장된 바이트(2진수)를 인터넷을 경유하여 응답.
  3. 브라우저는 서버가 응답한 `HTML` 문서를 바이트의 형태로 응답 받음.
  4. 응답된 바이트 형태의 `HTML` 문서는 `meta` 태그의 `charset` 어트리뷰트(응답 헤더, `response header`에 담김)에 의해 지정된 인코딩 방식을 기준으로 문자열로 변환.
  5. 문자열로 변환된 `HTML` 문서를 읽어 들여 문법적 의미를 갖는 최소 단위인 토큰(`token`)들로 분해.
  6. 각 토큰들을 객체로 변환하여 노드(`node`)들을 생성. 토큰의 내용에 따라 문서 노드, 요소 노드, 어트리뷰트 노드, 텍스트 노드가 생성. 노드는 이후 `DOM`을 구성하는 기본 요소가 됨.
  7. `HTML` 문서는 `HTML` 요소들의 집합으로 이루어지며, `HTML` 요소는 중첩 관계를 가짐. 즉, `HTML` 요소 간의 중첩 관계에 의해 부자 관계가 형성되고, 이러한 부자 관계를 반영하여 모든 노드들을 트리 자료구조로 구성.

  > 노드들로 구성된 트리 자료구조를 `Document Object Model`(`DOM`)이라고 함.

> 즉, `DOM`은 `HTML` 문서를 파싱한 결과물.

## `CSS` 파싱과 `CSSOM` 생성

- 렌더링 엔진은 `HTML`을 처음부터 한 줄씩 순차적으로 파싱하여 `DOM`을 생성.
- 렌더링 엔진은 `DOM`을 생성해 나가다가 `CSS`를 생성하는 `style`, `link` 태그를 만나면 `DOM` 생성을 일시 중지.
- `CSS`를 `HTML`과 동일한 파싱 과정(바이트 -> 문자 -> 토큰 -> 노드 -> `CSSOM`)을 거쳐 해석하여 `CSS Object Model`(`CSS`)를 생성.
- 이후 `CSS` 파싱을 완료하면 다시 중단 지점부터 `HTML`을 파싱하기 시작하여 `DOM` 생성을 재개.
- `CSSOM`은 `CSS`의 상속을 반영하여 생성.
- Ex) `body` 요소에 적용한 `font-size` 프로퍼티와 `ul` 요소에 적용한 `list-style-type` 프로퍼티는 모든 `li` 요소에 상속.

## 렌더 트리 생성

- 렌더링 엔진은 서버로부터 응답된 `HTML`, `CSS`를 파싱하여 각각 `DOM`과 `CSSOM`을 생성하고, `DOM`과 `CSSOM`은 렌더링을 위해 렌더 트리(`render tree`)로 결합.
- 렌더 트리는 렌더링을 위한 트리 자료구조이므로, 브라우저 화면에 렌더링되지 않는 노드(`meta 태그`, `script` 태그 등)와 `CSS`에 의해 비표시(`display: none;`)되는 노드들은 포함하지 않음.

> 렌더 트리는 브라우저 화면에 렌더링되는 노드만으로 구성.

- 이후 완성된 렌더 트리는 각 `HTML` 요소의 레이아웃(위치, 크기)를 계산하는데 사용되며 브라우저 화면에 픽셀을 렌더링하는 페인팅(`painting`) 처리에 입력.
- 브라우저의 렌더링 과정은 반복해서 실행 가능.
- 브라우저 렌더링 과정 반복이 발생하는 경우.
  1. `JavaScript`에 의한 노드 추가 또는 삭제.
  2. 브라우저 창 리사이징에 의한 뷰포트(`viewport`) 크기 변경.
  3. `HTML` 요소의 레이아웃(위치, 크기)에 변경을 발생시키는 `width`, `height`, `margin`, `padding`, `border`, `display`, `position` 등의 스타일 변경

> 레이아웃 계산과 페인팅을 다시 실행하는 리렌더링은 비용이 많이 드는. 즉, 성능에 악영향을 주는 작업.

> 따라서 가급적 리렌더링이 빈번하게 발생하지 않도록 주의.

## `JavaScript` 파싱과 실행

- `DOM`은 `HTML` 문서의 구조와 정보뿐만 아니라 `HTML` 요소와 스타일 등을 변경할 수 있는 프로그래밍 인터페이스로서 `DOM API`를 제공.
- `JavaScript` 코드에서 `DOM API`를 사용하면 이미 생성된 `DOM`을 동적으로 조작 가능.
- `CSS` 파싱과 마찬가지로 브라우저 렌더링 엔진은 `HTML`을 한 줄씩 순차적으로 파싱하며 `DOM`을 생성해 나가다가 `script` 태그를 만나면 `DOM` 생성을 일시 중지.
- 로드한 `JavaScript`를 파싱하기 위해 `JavaScript Engine`에 제어권을 넘김.
- 이후 `JavaScript` 파싱을 완료하면 다시 중단 지점부터 `HTML`을 파싱하기 시작하여 `DOM` 생성을 재개.
- `JavaScript` 파싱과 실행은 브라우저 렌더링 엔진이 아닌 `JavaScript Engine`이 처리.
- `JavaScript Engine`은 `JavaScript` 코드를 파싱하여 `CPU`가 이해할 수 이쓴 저수준 언어(`low-level language`)로 변환하고 실행하는 역할.
- 브라우저 렌더링 엔진이 `HTML`, `CSS`를 파싱하여 `DOM`과 `CSSOM`을 생성하듯, `JavaScript Engine`은 `JavaScript`를 해석하여 `Abstract Syntax Tree`(추상 구문 트리, `AST`)를 생성.
- `AST`를 기반으로 인터프리터가 실행할 수 있는 중간 코드(`intermediate`)인 바이트코드를 생성하여 실행.

### 토크나이징(`tokenizing`)

- 단순한 문자열인 `JavaScript` 소스코드를 어휘 분석(`lexical analysis`)하여 문법적 의미를 갖는 최소 단위인 토큰(`token`)들로 분해.
- 이 과정을 렉싱(`lexing`)이라고 부르기도 하지만 토크나이징과 미묘한 차이 존재.

### 파싱(`parsing`)

- 토큰들의 집합을 구문 분석(`syntax analysis`)하여 `AST`를 생성.
- `AST`는 토큰에 문법적 의미와 구조를 반영한 트리 구조의 자료구조.
- `AST`는 인터프리터나 컴파일러 뿐만 아니라, 트랜스파일러를 구현할 수도 있음.

### 바이트코드 생성과 실행

- 파싱의 결과물로서 생성된 `AST`는 인터프리터가 실행할 수 있는 중간 코드인 바이트코드로 변환되고 인터프리터에 의해 실행.
- `V8` 엔진의 경우 자주 사용되는 코드는 터보팬(`TurboFan`)이라 불리는 컴파일러에 의해 최적화된 머신 코드(`optimized machine code`)로 컴파일되어 성능을 최적화.
- 코드의 사용 빈도가 적어지면 다시 디옵티마이징(`deoptimizing`)하기도 함.

## 리플로우와 리페인트

- `DOM API`를 사용하여 `DOM` 또는 `CSSOM`을 변경할 경우, 변경된 `DOM`, `CSSOM`은 다시 렌더 트리로 결합.
- 변경된 렌더 트리를 기반으로 레이아웃과 페인트 과정을 거쳐 브라우저의 화면에 다시 렌더링.

> 이를 리플로우(`reflow`), 리페인팅(`repaint`)라고 함.

### 리플로우

- 레이아웃 계산을 다시 하는 것.
- 노드 추가/삭제, 요소의 크기/위치 변경.
- 윈도우 리사이징 등 레이아웃에 영향을 주는 변경이 발생한 경우에 한하여 실행.

### 리페인트

- 재결합된 렌더 트리를 기반으로 다시 페인트하는 것.

> 리플로우와 리페인트가 반드시 순차적으로 동시에 실행되는 것은 아님.  
> 레이아웃에 영향이 없는 변경은 리플로우 없이 리페인트만 실행.

## `JavaScript` 파싱에 의한 `HTML` 파싱 중단

- 브라우저는 동기적(`synchronous`)으로. 즉, 위에서 아래 방향으로 순차적으로 `HTML`, `CSS`, `JavaScript`를 파싱하고 실행.
- `script` 태그의 위치에 따라 `HTML` 파싱이 블로킹되어 `DOM` 생성이 지연될 수 있으므로, `script` 태그의 위치는 중요한 의미.
- 이러한 문제를 회피하기 위해 `body` 요소의 가장 아래에 `JavaScript`를 위치시키는 것은 좋은 아이디어.

  1. `DOM`이 완성되지 않은 상태에서 `JavaScript`가 `DOM`을 조작하면 에러 발생.
  2. `JavaScript` 로딩/파싱/실행으로 인해 `HTML` 요소들의 렌더링에 지장받는 일이 발생하지 않아 로딩 시간이 단축.

## `script` 태그의 `async`/`defer` 어트리뷰트

- `JavaScript` 파싱에 의한 `DOM` 생성이 중단(`blocking`)되는 문제를 근본적으로 해결하기 위해 `HTML5` 부터 `script` 태그에 `async`/`defer` 어트리뷰트가 추가.
- `async`와 `defer` 어트리뷰트는 `src` 어트리뷰트를 통해 외부 `JavaScript` 파일을 로드하는 경우에만 사용. => 인라인 `JavaScript`에서는 사용할 수 없음.
- `async`와 `defer` 어트리뷰트를 사용하면 `HTML`의 파싱과 외부 `JavaScript` 파일의 로드가 비동기적(`asynchronmous`)으로 동시에 진행.

### `async` 어트리뷰트

- `HTML` 파싱과 외부 `JavaScript` 파일의 로드가 비동기적으로 동시에 진행.
- `JavaScript` 파싱과 실행은 `JavaScript` 파일의 로드가 완료된 직후 진행되며, 이때 `HTML` 파싱 중단.
- 순서와는 상관없이 로드가 완료된 `JavaScript` 먼저 실행되므로 순서 보장 X

> `IE10` 이상에서 지원

### `defer` 어트리뷰트

- `HTML` 파싱과 외부 `JavaScript` 파일의 로드가 비동기적으로 동시에 진행.
- `JavaScript` 파싱과 실행은 `HTML` 파싱이 완료된 직후. 즉, `DOM` 생성이 완료된 직후(이때 `DOMContentLoaded` 이벤트가 발생)에 진행.
- 따라서 `DOM` 생성이 완료된 이후에 실행되어야 할 `JavaScript`에 유용.

> `IE10` 이상에서 지원

> `IE6~IE9`에서도 지원되기는 하지만 정상적으로 동작하지 않을 수 있음.
