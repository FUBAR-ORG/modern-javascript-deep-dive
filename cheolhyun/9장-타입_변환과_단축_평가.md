# 타입 변환과 단축 평가

## 타입 변환이란?

- 개발자가 의도적으로 값의 타입을 변환하는 것을 명시적 타입 변환(`explicit coercion`) 또는 타입 캐스팅(`type casting`)이라 함.
- 개발자의 의도와는 상관없이 표현식을 평가하는 도중에 `JavaScript Engine`에 의해 암묵적으로 타입이 변환되는 것을 암묵적 타입 변환(`implicit coercion`) 또는 타입 강제 변환(`type coercion`)이라 함.
- 원시 값은 변경 불가능한 값(`immutable value`) 이므로 타입 변환이 기존 원시 값을 직접 변경하는 것은 아님.
- 타입 변환이란 기존 원시 값을 사용해 다른 타입의 새로운 원시 값을 생성하는 것.
- 암묵적 타입 변환은 기존 변수 값을 재할당하여 변경하는 것이 아님.
- 타입 변환 결과를 예측하지 못한다면 오류를 생산할 가능성이 높아짐.

## 암묵적 타입 변환

- 암묵적 타입 변환이 발생하면 `string`, `number`, `boolean`과 같은 원시 타입 중 하나로 타입을 자동 변환.
- `JavaScript Engine`은 표현식을 평가할 때 코드 문백에 부합하도록 암묵적 타입 변환을 실행.

### 문자열 타입으로 변환

- `+` 연산자의 피연산자 중 하나 이상이 문자열일 경우 문자열 연결 연산자로 동작해야 하므로 문자열로 타입 변환.
- `ES6`에서 도입된 템플릿 리터럴의 표현식 삽입은 표현식의 평가 결과를 문자열 타입으로 암묵적 타입 변환.

```js
1 + "2"; // "12"
`1 + 1 = ${1 + 1}`; // "1 + 1 = 2"
```

- 문자열 타입 암묵적 타입 변환 예시

```js
0 + ""; // "0"
-0 + ""; // "0"
NaN + ""; // "NaN"
Infinity + ""; // "Infinity"
-Infinity + ""; // "-Infinity"

true + ""; // "true"
false + ""; // "false"

null + ""; // "null"

undefined + ""; // "undefined"

Symbol() + ""; // TypeError: Cannot convert a Symbol value to a string

({} + ""); // "[object Object]"
Math + ""; // "[object Math]""
[] + ""; // ""
[10, 20] + ""; // "10,20"
(function () {} + ""); // "function(){}"
Array + ""; // "function Array() { [native code] }"
```

### 숫자 타입으로 변환

- 산술 연산자, 비교 연산자, 단항 연산자는 숫자 타입으로 암묵적 타입 변환.
- 숫자 타입으로 변환할 수 없는 경우 평가 결과는 `NaN`.
- 빈 문자열(`''`), 빈 배열(`[]`), `null`, `false`는 `0`, `true`는 `1`로 변환.
- `undefined`는 변환이 되지 않아 `NaN`.

### 불리언 타입으로 변환

- 조건식의 평가 결과를 불리언 타입으로 암묵적 타입 변환.
- `false`, `undefined`, `null`, `0`, `-0`, `NaN`, `''`을 `false`로 평가함.
- 이 외에는 모두 `true`로 평가함.

## 명시적 타입 변환

- 명시적으로 타입을 변경하는 방법

  - 표준 빌트인 생성자 함수(`String`, `Number`, `Boolean`)을 `new` 연산자 없이 호출.
  - 빌트인 메서드 이용.
  - 암묵적 타입 변환 이용.

### 문자열 타입으로 변환

1. `String` 생성자 함수를 `new` 연산자 없이 호출하는 방법.
2. `Object.prototype.toString` 메서드를 사용하는 방법.
3. 문자열 연결 연산자를 이용하는 방법.

### 숫자 타입으로 변환

1. `Number` 생성자 함수를 `new` 연산자 없이 호출하는 방법.
2. `parseInt`, `parseFloat` 함수를 사용하는 방법(문자열만 변환 가능)
3. 단항 산술 연산자를 이용하는 방법.
4. 산술 연산자를 이용하는 방법.

### 불리언 타입으로 변환

1. `Boolean` 생성자 함수를 `new` 연산자 없이 호출하는 방법.
2. `!` 부정 논리 연산자를 두 번 사용하는 방법.

## 단축 평가

- 단축 평가(`short-circuit evaluation`)는 표현식을 평가하는 도중에 평가 결과가 확정된 경우 나머지 평가 과정을 생략하는 것.

### 단축 평가가 유용하게 사용되는 경우

- 객체를 가리키기를 기대하는 변수가 `null` 또는 `undefined`가 아닌지 확인하고 프로퍼티를 참조할 때
- 함수 매개변수에 기본 값을 설정할 때

### 논리 연산자를 사용한 단축 평가

- 논리 연산의 결과를 결정하는 피연산자를 타입 변환하지 않고 그대로 반환.
- 단축 평가를 통해 `if` 문 대체 가능.

  - 어떤 조건이 `true`일 때 무언가를 해야 한다면 논리곱(`&&`) 연산자 표현식으로 대체.
  - 어떤 조건이 `false`일 때 무언가를 해야 한다면 논리합(`||`) 연산자 표현식으로 대체.

### 옵셔널 체이닝 연산자

- `ES11`(`ECMAScript2020)`에 도입된 옵셔널 체이닝(`optional chaining`) 연산자 `?.`는 좌항의 피연산자가 `null` 또는 `undefined`인 경우 `undefined`를 반환하고, 그렇지 않으면 우항의 프로퍼티 참조를 이어감.
- 객체를 가리키기를 기대하는 변수가 `null` 또는 `undefined`가 아닌지 확인하고 프로퍼티를 참조할 때 유용.
- 도입되기 이전에는 논리 연산자 `&&`를 사용한 단축 평가를 통해 확인.
- 논리 연산자는 좌항의 피연산자가 `false`로 평가되는 값이면 좌항 피연산자를 그대로 반환.
- 옵셔널 체이닝 연산자는 좌항의 피연산자가 `false`이라도 `null` 또는 `undefined`가 아니면 우항의 프로퍼티 참조를 이어감.

### `null` 병합 연산자

- `ES11`에서 도입된 `null` 병합(`nullish coalescing`) 연산자 `??`는 좌항이 피연산자가 `null` 또는 `undefined`인 경우 우항의 피연산자를 반환하고, 그렇지 않으면 좌항의 피연산자를 반환.
- 변수에 기본값을 설정할 때 유용.
- 도입되기 이전에는 논리 연산자 `||`를 사용한 단축 평가를 통해 설정.
- 논리 연산자는 좌항의 피연산자가 `false`로 평가되는 값이면 우항의 피연산자를 반환.
- `null` 병합 연산자는 좌항의 피연산자가 `false`이더라도 `null` 또는 `undefined`가 아니면 좌항의 피연산자를 그대로 반환.
